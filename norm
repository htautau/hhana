#!/usr/bin/env python

"""
This performs the so-called "track fit" to determine the QCD and Z normalization
in each of the categories. These normalizations are cached in cache/norms.cache
and later used by the rest of the analysis framework.

For a list of all options this script accepts please see::

    ./norm --help
"""

from mva.cmd import fit_parser

parser = fit_parser()
args = parser.parse_args()

import sys

from rootpy.io import root_open
from rootpy.plotting import Hist2D, Hist

from mva.samples import Data, MC_Ztautau, Embedded_Ztautau, Others, QCD, Higgs
from mva.stats import histfactory
from mva.stats.fit import fit
from mva.massregions import MassRegions
from mva.norm import cache, log
from mva.plotting import draw_samples
from mva.systematics import SYSTEMATICS
from mva.categories import CATEGORIES
from matplotlib.ticker import FuncFormatter

import ROOT
from ROOT import RooMinimizer

from externaltools import TrackFit

track_fit = False

if args.param == 'track':
    
    track_fit = True
    # fit the 2D recounted number of track distribution
    expr = 'tau1_numTrack_recounted:tau2_numTrack_recounted'
    # define the 2D boundaries and number of bins
    min_edge, max_edge = .5, 3.5
    bins = int(max_edge - min_edge)
    integer = True
    xaxis_label = "Recounted Number of Tracks"

    # define the histogram template
    hist_template = Hist2D(bins, min_edge, max_edge,
                           bins, min_edge, max_edge, type='D')

    def xtick_track_func(x, pos):
        # used by matplotlib to label the x axis with the (#track1, #track2) tuples 
        ntrack1 = int((x - 1) / bins) + 1
        ntrack2 = (x - 1) % bins + 1
        return "(%d,%d)" % (ntrack1, ntrack2)

    xtick_formatter = FuncFormatter(xtick_track_func)
    xtick_rotation = 90
    param = 'TRACK'
    
    mass_regions = MassRegions(low_cutoff=60, low=100, high=120,
                               high_sideband_in_control=True)
    control_region = None
    control_region = mass_regions.control_region

    fit_region = 'SS'
    fit_region_alias = 'SS_TRK'
    target_region = 'nOS'
    
    virtual_region = 'SS_TRK'
    model_region = 'OS'

elif args.param == 'mass':

    expr = 'mass_mmc_tau1_tau2'
    min_edge, max_edge = 50, 90
    bins = 7
    integer = False
    xaxis_label = "MMC [GeV]"
    hist_template = Hist(bins, min_edge, max_edge)
    xtick_formatter = None
    xtick_rotation = 0
    param = 'MASS'
    control_region = None

    fit_region = 'nOS'
    fit_region_alias = 'nOS'
    target_region = 'nOS'
    
    #fit_region = 'SS_TRK'
    #fit_region_alias = 'SS_TRK'
    #target_region = 'SS_TRK'

    virtual_region = 'SS_TRK'
    model_region = 'OS_TRK'

else:
    sys.exit("invalid fitting param: %s" % args.param)

before_name = "bkg_before_%sfit" % param
after_name = "bkg_after_%sfit" % param

year = 2012

# The year param below should eventually be given by the user from the command
# line (defaulting to 2012) but currently is hard coded as 2012
data = Data(2012)
if args.embedding:
    # Use embedded Z->tau+tau
    ztt = Embedded_Ztautau(2012, systematics=True)
    before_name += '_embedded'
    after_name += '_embedded'
else:
    # Use ALPGEN Z->tau+tau
    ztt = MC_Ztautau(2012, systematics=True)
others = Others(2012, systematics=True)
qcd = QCD(data, mc=(ztt, others))
qcd.label = 'QCD Multi-jet'
higgs = Higgs(year=2012, mass=125, systematics=True)
systematics = False

# loop over category definitions
for cat_def in args.categories:
    # loop over the categories
    for category in CATEGORIES[cat_def]:
        
        log.info(data.cuts(category, model_region))
        
        # Initialize Z scale to (data - QCD - others) / Z
        # so we get good convergence for ALPGEN or embedded Z
        ztt.scale = 1.
        ztt.scale_error = 0.
        qcd.shape_region = fit_region
        if fit_region == 'nOS':
            qcd_scale_init = 0.1
        else:
            qcd_scale_init = 1.
        qcd.scale = qcd_scale_init
        qcd.scale_error = 0.

        data_events = data.events(category, model_region, cuts=control_region)
        qcd_events = qcd.events(category, model_region, cuts=control_region)
        oth_events = others.events(category, model_region, cuts=control_region)
        z_events = ztt.events(category, model_region, cuts=control_region)
        scale_init = (data_events - qcd_events - oth_events) / float(z_events)
        ztt.scale = scale_init
        log.info("initial Z scale before fit: %f" % scale_init)

        if args.plot:
            # Draw the distribution before the fit
            draw_samples(hist_template, expr,
                    model=[qcd, others, ztt],
                    data=data,
                    category=category,
                    region=model_region,
                    cuts=control_region,
                    name=xaxis_label,
                    output_name=before_name,
                    show_ratio=True,
                    systematics=SYSTEMATICS.values(),
                    ravel=hist_template.GetDimension() > 1,
                    integer=integer,
                    xtick_formatter=xtick_formatter,
                    xtick_rotation=xtick_rotation)
        
        if args.roofit:
            # Request HistFactory Samples for each of the model components
            ztt_sample = ztt.get_histfactory_sample(
                    hist_template, expr, category, model_region,
                    cuts=control_region,
                    systematics=systematics)
            ztt_sample_hist = ztt_sample.GetHisto().Clone()
            others_sample = others.get_histfactory_sample(
                    hist_template, expr, category, model_region,
                    cuts=control_region,
                    systematics=systematics)
            others_sample_hist = others_sample.GetHisto().Clone()
            qcd_sample = qcd.get_histfactory_sample(
                    hist_template, expr, category, model_region,
                    cuts=control_region,
                    systematics=systematics)
            qcd_sample_hist = qcd_sample.GetHisto().Clone()
            data_sample = data.get_histfactory_sample(
                    hist_template, expr, category, model_region,
                    cuts=control_region)
            data_sample_hist = data_sample.GetHisto().Clone()
            
            # Define the floating norm parameters that will be fitted
            ztt_sample.AddNormFactor('z_scale', 1., 0, 50)
            qcd_sample.AddNormFactor('qcd_scale', 1., 0, 50)
            
            # Construct a HistFactory Channel and Measurement and then the Workspace
            # Note: The following is based on HistFitter code
            
            channel = histfactory.make_channel(category.name,
                    [ztt_sample, others_sample, qcd_sample], data_sample.GetHisto())
            measurement = histfactory.make_measurement('trackfit', '', [channel],
                    lumi_rel_error=0.028,
                    POI=['z_scale', 'qcd_scale'])
            workspace = histfactory.make_model(measurement)

            # Get the observed data and model PDF
            obs_data = workspace.data('obsData')
            pdf = workspace.pdf('model_channel_%s' % category.name)
            # fit the model pdf to the observed data
            fit_result = fit(pdf, obs_data)
                
            # Get the fitted Z and QCD normalizations and associated uncertainties
            z_scale_arg = fit_result.floatParsFinal().find("z_scale")
            z_scale = z_scale_arg.getValV() * scale_init
            z_scale_error = z_scale_arg.getError() * scale_init

            qcd_scale_arg = fit_result.floatParsFinal().find("qcd_scale")
            qcd_scale = qcd_scale_arg.getValV() * qcd_scale_init
            qcd_scale_error = qcd_scale_arg.getError() * qcd_scale_init
            
            log.info("data / model of templates after fit: %f" %
                 (data_sample_hist.Integral() / (
                     ztt_sample_hist.Integral() * z_scale / scale_init +
                     others_sample_hist.Integral() +
                     qcd_sample_hist.Integral() * qcd_scale)))

        else: # use original TrackFit code
            fitter = ROOT.TrackFit.TrackFitter()
            
            data_hist = hist_template.Clone()
            data.draw_into(data_hist, expr, category, model_region,
                    cuts=control_region, systematics=False)
            
            tau_hist = hist_template.Clone() 
            ztt.draw_into(tau_hist, expr, category, model_region,
                    cuts=control_region, systematics=False)

            qcd_hist = hist_template.Clone()
            qcd.draw_into(qcd_hist, expr, category, model_region,
                    cuts=control_region, systematics=False)

            others_hist = hist_template.Clone()
            others.draw_into(others_hist, expr, category, model_region,
                    cuts=control_region, systematics=False)

            higgs_hist = hist_template.Clone()
            higgs.draw_into(higgs_hist, expr, category, model_region,
                    cuts=control_region, systematics=False)

            fit_result = fitter.fit(
                    data_hist, tau_hist, qcd_hist, others_hist, higgs_hist,
                    qcd_hist, qcd_hist, tau_hist, tau_hist)
            
            """
            with root_open('sample_templates.root', 'recreate'):
                data_hist.Write('data')
                tau_hist.Write('ztautau')
                qcd_hist.Write('qcd')
                others_hist.Write('others')
                higgs_hist.Write('higgs')
            """
            
            z_scale = fit_result.sfZ * scale_init
            z_scale_error = 0.

            qcd_scale = fit_result.sfQCD * qcd_scale_init
            qcd_scale_error = 0.

        # Cache the fitted normalization scale factors
        cache.set_scales(
                year,
                category.name, args.embedding, param,
                fit_region_alias,
                qcd_scale, qcd_scale_error,
                z_scale, z_scale_error)
        
        ztt.scale = z_scale
        ztt.scale_error = z_scale_error
        
        if track_fit:
            # nOS QCD model
            # Correct the QCD scale to account for difference between fitting model
            # and target model (SS vs !OS)
            # The final OS model includes the requirement that the number of recounted
            # tracks equals 1 or 3 for both taus, so we need to scale the QCD to what would
            # be expected after this requirement
            # Note: All regions are defined in mva/regions.py
            qcd.shape_region = 'SS_TRK'
            qcd_events = qcd.events(category, model_region)
            qcd_events_ss = qcd.events(category, model_region, cuts=control_region)
            qcd.shape_region = 'nOS'
            qcd_events_target = qcd.events(category, model_region)
            qcd_scale_corrected = qcd_events / qcd_events_target
            cache.set_scales(
                    year,
                    category.name, args.embedding, param,
                    'nOS',
                    qcd_scale * qcd_scale_corrected,
                    qcd_scale_error * qcd_scale_corrected,
                    z_scale, z_scale_error)

            qcd.scale = qcd_scale * qcd_scale_corrected
            qcd.scale_error = qcd_scale_error * qcd_scale_corrected
            
            qcd_events_nos = qcd.events(category, 'OS_TRK', cuts=control_region)

            log.info("QCD SS_TRK events in mass control: %f" % (qcd_events_ss * qcd_scale))
            log.info("QCD nOS events in mass control: %f" % qcd_events_nos)
            
            data_events = data.events(category, 'OS_TRK', cuts=control_region)
            ztt_events = ztt.events(category, 'OS_TRK', cuts=control_region)
            oth_events = others.events(category, 'OS_TRK', cuts=control_region)
            
            model_events_nos = ztt_events + oth_events + qcd_events_nos
            model_events_ss = ztt_events + oth_events + qcd_events_ss * qcd_scale

            log.info("data / model (SS_TRK QCD) in the mass control: %f" %
                     (data_events / model_events_ss))
            log.info("data / model (nOS QCD) in the mass control: %f" %
                     (data_events / model_events_nos))
        
        qcd.scale = qcd_scale
        qcd.scale_error = qcd_scale_error
        qcd.shape_region = fit_region
        
        if args.plot:
            # Draw the distribution after the fit
            draw_samples(hist_template, expr,
                    model=[qcd, others, ztt],
                    data=data,
                    category=category,
                    region=model_region,
                    cuts=control_region,
                    name=xaxis_label,
                    output_name=after_name,
                    show_ratio=True,
                    systematics=SYSTEMATICS.values(),
                    ravel=hist_template.GetDimension() > 1,
                    integer=integer,
                    xtick_formatter=xtick_formatter,
                    xtick_rotation=xtick_rotation)
